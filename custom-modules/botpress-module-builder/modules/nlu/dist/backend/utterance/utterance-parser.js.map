{"version":3,"sources":["utterance/utterance-parser.ts"],"names":["ALL_SLOTS_REGEX","extractSlots","utterance","slotMatches","matches","exec","push","parseUtterance","cursor","parsed","reduce","acc","fullMatch","value","name","index","inBetweenText","slice","trailingText","nbPrefixSpaces","length","trimLeft","nbTrailingSpaces","trimRight","repeat","clean","parsedSlot","rawPosition","start","end","cleanPosition","parsedSlots","parts","text","slot","filter","x"],"mappings":"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","sourceRoot":"/src/modules/nlu/src/backend","sourcesContent":["import _ from 'lodash'\n\nconst ALL_SLOTS_REGEX = /\\[(.+?)\\]\\(([\\w_\\. :-]+)\\)/gi\n\nexport interface ParsedSlot {\n  name: string\n  value: string\n  rawPosition: {\n    start: number\n    end: number\n  }\n  cleanPosition: {\n    start: number\n    end: number\n  }\n}\n\nexport interface UtterancePart {\n  text: string\n  slot?: ParsedSlot\n}\n\nexport interface ParsedUtterance {\n  utterance: string\n  parsedSlots: ParsedSlot[]\n  parts: UtterancePart[]\n}\n\nexport const extractSlots = (utterance: string): RegExpExecArray[] => {\n  const slotMatches: RegExpExecArray[] = []\n  let matches: RegExpExecArray | null\n  while ((matches = ALL_SLOTS_REGEX.exec(utterance)) !== null) {\n    slotMatches.push(matches)\n  }\n\n  return slotMatches\n}\n\nexport const parseUtterance = (utterance: string): ParsedUtterance => {\n  let cursor = 0\n  const slotMatches = extractSlots(utterance)\n\n  const parsed = slotMatches.reduce(\n    (acc, { 0: fullMatch, 1: value, 2: name, index }) => {\n      let inBetweenText = utterance.slice(cursor, index)\n      let trailingText = ''\n\n      const nbPrefixSpaces = value.length - value.trimLeft().length\n      const nbTrailingSpaces = value.length - value.trimRight().length\n      if (nbPrefixSpaces) {\n        inBetweenText += ' '.repeat(nbPrefixSpaces)\n        value = value.trimLeft()\n      }\n      if (nbTrailingSpaces) {\n        trailingText += ' '.repeat(nbTrailingSpaces)\n        value = value.trimRight()\n      }\n\n      const clean = acc.utterance + inBetweenText + value + trailingText\n      cursor = index + fullMatch.length // index is stateful since its a general regex\n      const parsedSlot: ParsedSlot = {\n        name,\n        value,\n        rawPosition: {\n          start: index,\n          end: cursor\n        },\n        cleanPosition: {\n          start: clean.length - value.length - nbTrailingSpaces - nbPrefixSpaces,\n          end: clean.length - nbPrefixSpaces - nbTrailingSpaces\n        }\n      }\n      return {\n        utterance: clean,\n        parsedSlots: [...acc.parsedSlots, parsedSlot],\n        parts: [\n          ...acc.parts,\n          { text: inBetweenText },\n          { text: value, slot: parsedSlot },\n          { text: trailingText }\n        ].filter(x => x.text.length)\n      }\n    },\n    { utterance: '', parsedSlots: [], parts: [] } as ParsedUtterance\n  )\n\n  if (cursor < utterance.length) {\n    parsed.utterance += utterance.slice(cursor)\n    parsed.parts = [...parsed.parts, { text: utterance.slice(cursor) }]\n  }\n  return parsed\n}\n"]}