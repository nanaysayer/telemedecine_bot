{"version":3,"sources":["model-service.ts"],"names":["MODELS_DIR","MAX_MODELS_TO_KEEP","makeFileName","hash","lang","computeModelHash","intents","entities","crypto","createHash","update","JSON","stringify","digest","serializeModel","ref","model","_","cloneDeep","entity","data","artefacts","list_entities","cache","dump","omit","deserializeModel","str","parse","slots_model","Buffer","from","pruneModels","ghost","languageCode","models","listModelsForLang","length","Promise","map","slice","file","deleteFile","endingPattern","directoryListing","undefined","sortOrder","column","desc","getModel","fname","fileExists","buffStream","Stream","PassThrough","end","readFileAsBuffer","tmpDir","tmp","dirSync","unsafeCleanup","tarStream","tar","x","cwd","name","strict","pipe","resolve","on","modelBuff","fse","readFile","path","join","mod","toString","err","removeCallback","getLatestModel","availableModels","split","saveModel","serialized","modelName","tmpFileName","writeFile","archiveName","create","portable","gzip","buffer","upsertFile"],"mappings":"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","sourceRoot":"/src/modules/nlu/src/backend","sourcesContent":["import * as sdk from 'botpress/sdk'\nimport crypto from 'crypto'\nimport fse, { WriteStream } from 'fs-extra'\nimport _ from 'lodash'\nimport path from 'path'\nimport { Stream } from 'stream'\nimport tar from 'tar'\nimport tmp from 'tmp'\n\nimport { TrainArtefacts, TrainInput, TrainOutput } from './training-pipeline'\nimport { EntityCache } from './typings'\n\nexport interface Model {\n  hash: string\n  languageCode: string\n  startedAt: Date\n  finishedAt: Date\n  success: boolean\n  data: {\n    input: TrainInput\n    output?: TrainOutput\n    artefacts?: TrainArtefacts\n  }\n}\n\nexport const MODELS_DIR = './models'\nconst MAX_MODELS_TO_KEEP = 2\n\nfunction makeFileName(hash: string, lang: string): string {\n  return `${hash}.${lang}.model`\n}\n\n// we might want to make this language specific\nexport function computeModelHash(intents: any, entities: any): string {\n  return crypto\n    .createHash('md5')\n    .update(JSON.stringify({ intents, entities }))\n    .digest('hex')\n}\n\nfunction serializeModel(ref: Model): string {\n  const model = _.cloneDeep(ref)\n  for (const entity of model.data.artefacts.list_entities) {\n    entity.cache = (<EntityCache>entity.cache)?.dump() ?? []\n  }\n  return JSON.stringify(_.omit(model, ['data.output', 'data.input.trainingSession']))\n}\n\nfunction deserializeModel(str: string): Model {\n  const model = JSON.parse(str) as Model\n  model.data.artefacts.slots_model = Buffer.from(model.data.artefacts.slots_model)\n  return model\n}\n\nexport async function pruneModels(ghost: sdk.ScopedGhostService, languageCode: string): Promise<void | void[]> {\n  const models = await listModelsForLang(ghost, languageCode)\n  if (models.length > MAX_MODELS_TO_KEEP) {\n    return Promise.map(models.slice(MAX_MODELS_TO_KEEP), file => ghost.deleteFile(MODELS_DIR, file))\n  }\n}\n\nexport async function listModelsForLang(ghost: sdk.ScopedGhostService, languageCode: string): Promise<string[]> {\n  const endingPattern = makeFileName('*', languageCode)\n  return await ghost.directoryListing(MODELS_DIR, endingPattern, undefined, undefined, {\n    sortOrder: { column: 'modifiedOn', desc: true }\n  })\n}\n\nexport async function getModel(ghost: sdk.ScopedGhostService, hash: string, lang: string): Promise<Model | undefined> {\n  const fname = makeFileName(hash, lang)\n  if (!(await ghost.fileExists(MODELS_DIR, fname))) {\n    return\n  }\n  const buffStream = new Stream.PassThrough()\n  buffStream.end(await ghost.readFileAsBuffer(MODELS_DIR, fname))\n  const tmpDir = tmp.dirSync({ unsafeCleanup: true })\n\n  const tarStream = tar.x({ cwd: tmpDir.name, strict: true }, ['model']) as WriteStream\n  buffStream.pipe(tarStream)\n  await new Promise(resolve => tarStream.on('close', resolve))\n\n  const modelBuff = await fse.readFile(path.join(tmpDir.name, 'model'))\n  let mod\n  try {\n    mod = deserializeModel(modelBuff.toString())\n  } catch (err) {\n    await ghost.deleteFile(MODELS_DIR, fname)\n  } finally {\n    tmpDir.removeCallback()\n    return mod\n  }\n}\n\nexport async function getLatestModel(ghost: sdk.ScopedGhostService, lang: string): Promise<Model | void> {\n  const availableModels = await listModelsForLang(ghost, lang)\n  if (availableModels.length === 0) {\n    return\n  }\n  return getModel(ghost, availableModels[0].split('.')[0], lang)\n}\n\nexport async function saveModel(ghost: sdk.ScopedGhostService, model: Model, hash: string): Promise<void | void[]> {\n  const serialized = serializeModel(model)\n  const modelName = makeFileName(hash, model.languageCode)\n  const tmpDir = tmp.dirSync({ unsafeCleanup: true })\n  const tmpFileName = path.join(tmpDir.name, 'model')\n  await fse.writeFile(tmpFileName, serialized)\n\n  const archiveName = path.join(tmpDir.name, modelName)\n  await tar.create(\n    {\n      file: archiveName,\n      cwd: tmpDir.name,\n      portable: true,\n      gzip: true\n    },\n    ['model']\n  )\n  const buffer = await fse.readFile(archiveName)\n  await ghost.upsertFile(MODELS_DIR, modelName, buffer)\n  tmpDir.removeCallback()\n  return pruneModels(ghost, model.languageCode)\n}\n"]}