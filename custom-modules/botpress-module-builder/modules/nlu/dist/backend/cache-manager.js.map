{"version":3,"sources":["cache-manager.ts"],"names":["cacheMap","getCacheId","name","prefix","getOrCreateCache","botId","options","cacheId","LRUCache","deleteCache","reset","copyCache","currentName","newName","currentCacheId","targetCacheId","_","clone","loadCacheFromData","data","cache","length","load","isCacheDump","has"],"mappings":";;;;;;;;;;;AAAA;;AACA;;;;AAEA,MAAMA,QAA6C,GAAG,EAAtD;;AAEA,SAASC,UAAT,CAAoBC,IAApB,EAAkCC,MAAc,GAAG,EAAnD,EAA+D;AAC7D,SAAQ,GAAEA,MAAO,IAAGD,IAAK,EAAzB;AACD;;AAEM,SAASE,gBAAT,CACLF,IADK,EAELG,KAFK,EAGLC,OAHK,EAIgB;AACrB,QAAMC,OAAO,GAAGN,UAAU,CAACC,IAAD,EAAOG,KAAP,CAA1B;;AACA,MAAI,CAACL,QAAQ,CAACO,OAAD,CAAb,EAAwB;AACtB;AACAP,IAAAA,QAAQ,CAACO,OAAD,CAAR,GAAoB,IAAIC,iBAAJ,CAAaF,OAAO,IAAI,IAAxB,CAApB;AACD;;AACD,SAAON,QAAQ,CAACO,OAAD,CAAf;AACD;;AAEM,SAASE,WAAT,CAAqBP,IAArB,EAAmCG,KAAnC,EAAmD;AAAA;;AACxD,QAAME,OAAO,GAAGN,UAAU,CAACC,IAAD,EAAOG,KAAP,CAA1B;AACA,uBAAAL,QAAQ,CAACO,OAAD,CAAR,wEAAmBG,KAAnB;AACA,SAAOV,QAAQ,CAACO,OAAD,CAAf;AACD;;AAEM,SAASI,SAAT,CAAmBC,WAAnB,EAAwCC,OAAxC,EAAyDR,KAAzD,EAAyE;AAC9E,QAAMS,cAAc,GAAGb,UAAU,CAACW,WAAD,EAAcP,KAAd,CAAjC;AACA,QAAMU,aAAa,GAAGd,UAAU,CAACY,OAAD,EAAUR,KAAV,CAAhC;AACAL,EAAAA,QAAQ,CAACe,aAAD,CAAR,GAA0BC,gBAAEC,KAAF,CAAQjB,QAAQ,CAACc,cAAD,CAAhB,CAA1B;AACD;;AAEM,SAASI,iBAAT,CACLC,IADK,EAELjB,IAFK,EAGLG,KAHK,EAIgB;AACrB,QAAMe,KAAK,GAAGhB,gBAAgB,CAAIF,IAAJ,EAAUG,KAAV,CAA9B;;AACA,MAAIe,KAAK,CAACC,MAAN,KAAiB,CAArB,EAAwB;AACtBD,IAAAA,KAAK,CAACE,IAAN,CAAWH,IAAX;AACD;;AACD,SAAOC,KAAP;AACD,C,CAED;;;AAEO,SAASG,WAAT,CAAqBJ,IAArB,EAAyC;AAC9C,SAAO,EAAE,QAAOA,IAAP,aAAOA,IAAP,uBAAOA,IAAI,CAAEK,GAAb,MAAqB,UAAvB,CAAP;AACD","sourceRoot":"/src/modules/nlu/src/backend","sourcesContent":["import _ from 'lodash'\nimport LRUCache from 'lru-cache'\n\nconst cacheMap: _.Dictionary<LRUCache<string, any>> = {}\n\nfunction getCacheId(name: string, prefix: string = ''): string {\n  return `${prefix}.${name}`\n}\n\nexport function getOrCreateCache<T>(\n  name: string,\n  botId?: string,\n  options?: LRUCache.Options<string, T>\n): LRUCache<string, T> {\n  const cacheId = getCacheId(name, botId)\n  if (!cacheMap[cacheId]) {\n    // @ts-ignore\n    cacheMap[cacheId] = new LRUCache(options || 1000)\n  }\n  return cacheMap[cacheId]\n}\n\nexport function deleteCache(name: string, botId?: string) {\n  const cacheId = getCacheId(name, botId)\n  cacheMap[cacheId]?.reset()\n  delete cacheMap[cacheId]\n}\n\nexport function copyCache(currentName: string, newName: string, botId?: string) {\n  const currentCacheId = getCacheId(currentName, botId)\n  const targetCacheId = getCacheId(newName, botId)\n  cacheMap[targetCacheId] = _.clone(cacheMap[currentCacheId])\n}\n\nexport function loadCacheFromData<T>(\n  data: LRUCache.Entry<string, T>[],\n  name: string,\n  botId?: string\n): LRUCache<string, T> {\n  const cache = getOrCreateCache<T>(name, botId)\n  if (cache.length === 0) {\n    cache.load(data)\n  }\n  return cache\n}\n\n// if necessary implement loadCacheFromPath\n\nexport function isCacheDump(data: any): boolean {\n  return !(typeof data?.has === 'function')\n}\n"]}