{"version":3,"sources":["intents/intent-vocab.test.ts"],"names":["LIST_ENTITIES","entityName","type","fuzzyTolerance","id","mappingsTokens","SPACE","languageCode","sensitive","u1Toks","split","u2Toks","genMockVectors","toks","Array","length","fill","genMockPOS","describe","test","expect","toEqual","intVocab","toBeUndefined","toBeTruthy","u1","Utterance","u2","allUtoks","map","t","toLowerCase","forEach","tagSlot","name"],"mappings":"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","sourceRoot":"/src/modules/nlu/src/backend","sourcesContent":["import { POSClass } from '../language/pos-tagger'\nimport { SPACE } from '../tools/token-utils'\nimport { buildIntentVocab } from '../training-pipeline'\nimport { ExtractedSlot, ListEntityModel } from '../typings'\nimport Utterance from '../utterance/utterance'\n\nconst LIST_ENTITIES: ListEntityModel[] = [\n  {\n    entityName: 'flights',\n    type: 'custom.list',\n    fuzzyTolerance: 0.8,\n    id: 'entId',\n    mappingsTokens: {\n      'Air Canada': [\n        ['Air', SPACE, 'Canada'],\n        ['air', 'can']\n      ]\n    },\n    languageCode: 'en',\n    sensitive: false\n  }\n]\n\nconst u1Toks = 'Hello my friend my name is Carl'.split(/(\\s)/)\nconst u2Toks = 'hello Anthony you look different. Anything new?'.split(/(\\s)/)\n\nconst genMockVectors = (toks: string[]): number[][] => new Array(toks.length).fill([0, 0])\nconst genMockPOS = (toks: string[]): POSClass[] => new Array(toks.length).fill('N/A')\n\ndescribe('Build intent vocab', () => {\n  test('Empty vocab', () => {\n    expect(buildIntentVocab([], [])).toEqual({})\n  })\n\n  test('With list entities only', () => {\n    const intVocab = buildIntentVocab([], LIST_ENTITIES)\n\n    expect(intVocab['hello']).toBeUndefined()\n    expect(intVocab[SPACE]).toBeUndefined()\n    expect(intVocab[' ']).toBeTruthy()\n    expect(intVocab['air']).toBeTruthy()\n    expect(intVocab['Air']).toBeUndefined()\n    expect(intVocab['Air Canada']).toBeUndefined()\n    expect(intVocab['air canada']).toBeUndefined()\n    expect(intVocab['Canada']).toBeUndefined()\n    expect(intVocab['canada']).toBeTruthy()\n    expect(intVocab['can']).toBeTruthy()\n  })\n\n  test('With utterance tokens only', () => {\n    const u1 = new Utterance(u1Toks, genMockVectors(u1Toks), genMockPOS(u1Toks), 'en')\n    const u2 = new Utterance(u2Toks, genMockVectors(u2Toks), genMockPOS(u2Toks), 'en')\n\n    const intVocab = buildIntentVocab([u1, u2], [])\n    const allUtoks = [...u1Toks, ...u2Toks]\n\n    expect(intVocab['air']).toBeUndefined()\n    expect(intVocab['Air']).toBeUndefined()\n    expect(intVocab['Air Canada']).toBeUndefined()\n    expect(intVocab['air canada']).toBeUndefined()\n    expect(intVocab['Canada']).toBeUndefined()\n    expect(intVocab['canada']).toBeUndefined()\n    expect(intVocab['can']).toBeUndefined()\n    allUtoks\n      .map((t: string) => t.toLowerCase())\n      .forEach(t => {\n        expect(intVocab[t]).toBeTruthy()\n      })\n  })\n\n  test('With list entities and Utterance tokens', () => {\n    const u1 = new Utterance(u1Toks, genMockVectors(u1Toks), genMockPOS(u1Toks), 'en')\n    const u2 = new Utterance(u2Toks, genMockVectors(u2Toks), genMockPOS(u2Toks), 'en')\n\n    const intVocab = buildIntentVocab([u1, u2], LIST_ENTITIES)\n    const allUtoks = [...u1Toks, ...u2Toks]\n\n    expect(intVocab[SPACE]).toBeUndefined()\n    expect(intVocab[' ']).toBeTruthy()\n    expect(intVocab['air']).toBeTruthy()\n    expect(intVocab['Air']).toBeUndefined()\n    expect(intVocab['Air Canada']).toBeUndefined()\n    expect(intVocab['air canada']).toBeUndefined()\n    expect(intVocab['Canada']).toBeUndefined()\n    expect(intVocab['canada']).toBeTruthy()\n    expect(intVocab['can']).toBeTruthy()\n    allUtoks\n      .map((t: string) => t.toLowerCase())\n      .forEach(t => {\n        expect(intVocab[t]).toBeTruthy()\n      })\n  })\n\n  test('Some tokens with tagged slots', () => {\n    const u1 = new Utterance(u1Toks, genMockVectors(u1Toks), genMockPOS(u1Toks), 'en')\n    u1.tagSlot({ name: 'person' } as ExtractedSlot, 6, 16) // slot is: \"my friend\"\n\n    const intVocab = buildIntentVocab([u1], [])\n\n    expect(intVocab['friend']).toBeUndefined() // not added because there's a slot\n    expect(intVocab['my']).toBeTruthy() // my is added because of its 2nd appearance\n  })\n})\n"]}