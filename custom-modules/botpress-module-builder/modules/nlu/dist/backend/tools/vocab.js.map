{"version":3,"sources":["tools/vocab.ts"],"names":["getMaxLevOps","token","candidateTok","longestLength","Math","max","length","getClosestToken","tokenStr","tokenVec","token2Vec","useSpacial","closestTok","dist","Number","POSITIVE_INFINITY","_","forEach","candidateVec","lev","maxLevOps","d"],"mappings":";;;;;;;AAAA;;AAIA;;AACA;;;;AAEA,SAASA,YAAT,CAAsBC,KAAtB,EAAqCC,YAArC,EAA2D;AACzD,QAAMC,aAAa,GAAGC,IAAI,CAACC,GAAL,CAASJ,KAAK,CAACK,MAAf,EAAuBJ,YAAY,CAACI,MAApC,CAAtB;;AACA,MAAIH,aAAa,IAAI,CAArB,EAAwB;AACtB,WAAO,CAAP;AACD,GAFD,MAEO,IAAIA,aAAa,IAAI,CAArB,EAAwB;AAC7B,WAAO,CAAP;AACD,GAFM,MAEA,IAAIA,aAAa,GAAG,EAApB,EAAwB;AAC7B,WAAO,CAAP;AACD,GAFM,MAEA;AACL,WAAO,CAAP;AACD;AACF;;AAEM,SAASI,eAAT,CACLC,QADK,EAELC,QAFK,EAGLC,SAHK,EAILC,UAAmB,GAAG,KAJjB,EAKG;AACR,MAAIC,UAAU,GAAG,EAAjB;AACA,MAAIC,IAAI,GAAGC,MAAM,CAACC,iBAAlB;;AACAC,kBAAEC,OAAF,CAAUP,SAAV,EAAqB,CAACQ,YAAD,EAAehB,YAAf,KAAgC;AACnD;AACA,UAAMiB,GAAG,GAAG,iCAAmBX,QAAnB,EAA6BN,YAA7B,CAAZ;AACA,UAAMkB,SAAS,GAAGpB,YAAY,CAACQ,QAAD,EAAWN,YAAX,CAA9B;;AACA,QAAIiB,GAAG,IAAIC,SAAP,IAAoBD,GAAG,GAAGN,IAA9B,EAAoC;AAClCA,MAAAA,IAAI,GAAGM,GAAP;AACAP,MAAAA,UAAU,GAAGV,YAAb;AACD,KAPkD,CASnD;;;AACA,UAAMmB,CAAC,GAAGV,UAAU,GAAG,qBAAoBF,QAApB,EAA8BS,YAA9B,CAAH,GAAiDJ,MAAM,CAACC,iBAA5E,CAVmD,CAWnD;;AACA,QAAIM,CAAC,GAAGR,IAAR,EAAc;AACZD,MAAAA,UAAU,GAAGV,YAAb;AACAW,MAAAA,IAAI,GAAGQ,CAAP;AACD;AACF,GAhBD;;AAiBA,SAAOT,UAAP;AACD","sourceRoot":"/src/modules/nlu/src/backend","sourcesContent":["import _ from 'lodash'\n\nimport { Token2Vec } from '../typings'\n\nimport { ndistance } from './math'\nimport { damerauLevenshtein } from './strings'\n\nfunction getMaxLevOps(token: string, candidateTok: string) {\n  const longestLength = Math.max(token.length, candidateTok.length)\n  if (longestLength <= 3) {\n    return 0\n  } else if (longestLength <= 4) {\n    return 1\n  } else if (longestLength < 10) {\n    return 2\n  } else {\n    return 3\n  }\n}\n\nexport function getClosestToken(\n  tokenStr: string,\n  tokenVec: number[] | ReadonlyArray<number>,\n  token2Vec: Token2Vec,\n  useSpacial: boolean = false\n): string {\n  let closestTok = ''\n  let dist = Number.POSITIVE_INFINITY\n  _.forEach(token2Vec, (candidateVec, candidateTok) => {\n    // Leveinshtein is for typo detection\n    const lev = damerauLevenshtein(tokenStr, candidateTok)\n    const maxLevOps = getMaxLevOps(tokenStr, candidateTok)\n    if (lev <= maxLevOps && lev < dist) {\n      dist = lev\n      closestTok = candidateTok\n    }\n\n    // Space (vector) distance is for close-meaning detection\n    const d = useSpacial ? ndistance(<number[]>tokenVec, candidateVec) : Number.POSITIVE_INFINITY\n    // stricly smaller, we want letter distance to take precedence over spacial\n    if (d < dist) {\n      closestTok = candidateTok\n      dist = d\n    }\n  })\n  return closestTok\n}\n"]}