{"version":3,"sources":["tools/math.ts"],"names":["ndistance","a","b","length","Error","total","i","diff","Math","sqrt","GetZPercent","z","factK","sum","term","k","loopStop","exp","abs","pow","computeNorm","vec","reduce","acc","next","add","args","_","vectorAdd","zipWith","scalarMultiply","multiplier","map","x","averageVectors","vecs","uniqBy","normalized","norm","scalarDivide","filter","Boolean","divider","allInRange","lower","upper","v","inRange","every","identity","zeroes","len","Array","fill","computeQuantile","quantile","target","upperBound","lowerBound","min","max","ceil","relativeStd"],"mappings":"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","sourceRoot":"/src/modules/nlu/src/backend","sourcesContent":["import _ from 'lodash'\nimport { log, std, mean } from 'mathjs'\n\n/**\n * Vectorial distance between two N-dimentional points\n * a[] and b[] must be of same dimention\n */\nexport function ndistance(a: number[], b: number[]): number {\n  if (a.length !== b.length) {\n    throw new Error(`Can't calculate distance between vectors of different length (${a.length} vs ${b.length})`)\n  }\n\n  let total = 0\n  for (let i = 0; i < a.length; i++) {\n    const diff = b[i] - a[i]\n    total += diff * diff\n  }\n  return Math.sqrt(total)\n}\n\nexport function GetZPercent(z: number) {\n  if (z < -6.5) {\n    return 0.0\n  }\n\n  if (z > 6.5) {\n    return 1.0\n  }\n\n  let factK = 1\n  let sum = 0\n  let term = 1\n  let k = 0\n  const loopStop = Math.exp(-23)\n\n  while (Math.abs(term) > loopStop) {\n    term =\n      (((0.3989422804 * Math.pow(-1, k) * Math.pow(z, k)) / (2 * k + 1) / Math.pow(2, k)) * Math.pow(z, k + 1)) / factK\n    sum += term\n    k++\n    factK *= k\n  }\n\n  sum += 0.5\n\n  return sum\n}\n\nexport function computeNorm(vec: number[]): number {\n  return Math.sqrt(vec.reduce((acc, next) => acc + Math.pow(next, 2), 0))\n}\n\nfunction add(...args: number[]) {\n  return args.reduce(_.add, 0)\n}\n\nexport function vectorAdd(...args: number[][]): number[] {\n  for (const vec of args) {\n    if (vec.length !== args[0].length) {\n      throw new Error('dimensions should match')\n    }\n  }\n\n  return _.zipWith(...args, add)\n}\n\nexport function scalarMultiply(vec: number[], multiplier: number): number[] {\n  return vec.map(x => x * multiplier)\n}\n\nexport function averageVectors(vecs: number[][]): number[] {\n  if (!vecs.length) {\n    return []\n  }\n\n  if (_.uniqBy(vecs, 'length').length > 1) {\n    throw new Error('Vectors must all be of the same size')\n  }\n\n  const normalized = vecs\n    .map(vec => {\n      const norm = computeNorm(vec)\n      if (norm) {\n        return scalarDivide(vec, norm)\n      }\n    })\n    .filter(Boolean)\n  return vectorAdd(...normalized)\n}\n\nexport function scalarDivide(vec: number[], divider: number): number[] {\n  return scalarMultiply(vec, 1 / divider)\n}\n\nexport function allInRange(vec: number[], lower: number, upper: number): boolean {\n  return vec.map(v => _.inRange(v, lower, upper)).every(_.identity)\n}\n\nexport function zeroes(len: number): number[] {\n  return Array(len).fill(0)\n}\n\n/**\n * @param quantile number of discret categories ex: 4 == quartile\n * @param target value to classify\n * @param upperBound maximum value the target can take\n * @param lowerBound minimum value the target can take\n * @returns integer value between [1, quantile]\n */\nexport function computeQuantile(quantile: number, target: number, upperBound: number, lowerBound: number = 0): number {\n  return Math.min(quantile, Math.max(Math.ceil(quantile * ((target - lowerBound) / (upperBound - lowerBound))), 1))\n}\n\n/**\n * @returns relative standard dev\n */\nexport function relativeStd(vec: number[]): number {\n  return std(vec) / mean(vec)\n}\n\nexport { log, std, mean }\n"]}