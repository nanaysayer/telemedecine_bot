{"version":3,"sources":["tools/cross-validation.ts"],"names":["seedrandom","require","TRAIN_SET_SIZE","makeIntentTestSet","rawUtts","ctxs","intent","lang","utterances","Engine","tools","map","utterance","splitSet","language","intents","lo","_","runInContext","testSet","trainSet","Promise","i","nTrain","Math","floor","length","MIN_NB_UTTERANCES","shuffle","trainUtts","slice","iTestSet","contexts","name","filter","Boolean","recordSlots","testU","extractedSlots","f1Scorer","slotList","values","tok","tokens","actual","get","find","s","start","offset","end","value","BIO","OUT","expected","record","crossValidate","botId","entities","global","engine","train","allCtx","chain","flatMap","uniq","intentF1Scorers","thru","reduce","byCtx","ctx","MultiClassF1Scorer","slotsF1Scorer","intentMap","ex","res","predict","toString","intentHasSlots","slots","fromPairs","toPairs","scorer","getResults"],"mappings":"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","sourceRoot":"/src/modules/nlu/src/backend","sourcesContent":["import { NLU } from 'botpress/sdk'\nimport _ from 'lodash'\n\nimport Engine from '../engine'\nimport { MIN_NB_UTTERANCES } from '../training-pipeline'\nimport { BIO } from '../typings'\nimport Utterance, { buildUtteranceBatch } from '../utterance/utterance'\n\nimport MultiClassF1Scorer, { F1 } from './f1-scorer'\nconst seedrandom = require('seedrandom')\n\ninterface CrossValidationResults {\n  intents: Dic<F1> //\n  slots: F1\n}\n\ninterface TestSetExample {\n  utterance: Utterance\n  ctxs: string[]\n  intent: string\n}\n\ntype TestSet = TestSetExample[]\ntype TrainSet = NLU.IntentDefinition[]\n\nconst TRAIN_SET_SIZE = 0.8\n\nasync function makeIntentTestSet(rawUtts: string[], ctxs: string[], intent: string, lang: string): Promise<TestSet> {\n  const utterances = await buildUtteranceBatch(rawUtts, lang, Engine.tools)\n  return utterances.map(utterance => ({\n    utterance,\n    ctxs,\n    intent\n  }))\n}\n\nasync function splitSet(language: string, intents: TrainSet): Promise<[TrainSet, TestSet]> {\n  const lo = _.runInContext() // so seed is applied\n  let testSet: TestSet = []\n  const trainSet = (\n    await Promise.map(intents, async i => {\n      // split data & preserve distribution\n      const nTrain = Math.floor(TRAIN_SET_SIZE * i.utterances[language].length)\n      if (nTrain < MIN_NB_UTTERANCES) {\n        return // filter out thouse without enough data\n      }\n\n      const utterances = lo.shuffle(i.utterances[language])\n      const trainUtts = utterances.slice(0, nTrain)\n      const iTestSet = await makeIntentTestSet(utterances.slice(nTrain), i.contexts, i.name, language)\n      testSet = [...testSet, ...iTestSet]\n\n      return {\n        ...i,\n        utterances: { [language]: trainUtts }\n      }\n    })\n  ).filter(Boolean)\n\n  return [trainSet, testSet]\n}\n\nfunction recordSlots(testU: Utterance, extractedSlots: NLU.SlotCollection, f1Scorer: MultiClassF1Scorer) {\n  const slotList = _.values(extractedSlots)\n\n  for (const tok of testU.tokens) {\n    const actual = _.get(\n      slotList.find(s => s.start <= tok.offset && s.end >= tok.offset + tok.value.length),\n      'name',\n      BIO.OUT\n    ) as string\n    const expected = _.get(tok, 'slots.0.name', BIO.OUT) as string\n    f1Scorer.record(actual, expected)\n  }\n}\n\n// pass k for k-fold is results are not significant\nexport async function crossValidate(\n  botId: string,\n  intents: NLU.IntentDefinition[],\n  entities: NLU.EntityDefinition[],\n  language: string\n): Promise<CrossValidationResults> {\n  seedrandom('confusion', { global: true })\n\n  const [trainSet, testSet] = await splitSet(language, intents)\n\n  const engine = new Engine(language, botId)\n  await engine.train(trainSet, entities, language)\n\n  const allCtx = _.chain(intents)\n    .flatMap(i => i.contexts)\n    .uniq()\n    .value()\n\n  const intentF1Scorers: Dic<MultiClassF1Scorer> = _.chain(allCtx)\n    .thru(ctxs => (ctxs.length > 1 ? ['all', ...ctxs] : ctxs))\n    .reduce((byCtx, ctx) => ({ ...byCtx, [ctx]: new MultiClassF1Scorer() }), {})\n    .value()\n\n  const slotsF1Scorer = new MultiClassF1Scorer()\n  const intentMap: Dic<NLU.IntentDefinition> = intents.reduce((map, i) => ({ ...map, [i.name]: i }), {})\n\n  for (const ex of testSet) {\n    for (const ctx of ex.ctxs) {\n      const res = await engine.predict(ex.utterance.toString(), [ctx])\n      intentF1Scorers[ctx].record(res.intent.name, ex.intent)\n      const intentHasSlots = !!intentMap[ex.intent].slots.length\n      if (intentHasSlots) {\n        recordSlots(ex.utterance, res.slots, slotsF1Scorer)\n      }\n    }\n    if (allCtx.length > 1) {\n      const res = await engine.predict(ex.utterance.toString(), allCtx)\n      intentF1Scorers['all'].record(res.intent.name, ex.intent)\n    }\n  }\n\n  seedrandom()\n  return {\n    intents: _.fromPairs(_.toPairs(intentF1Scorers).map(([ctx, scorer]) => [ctx, scorer.getResults()])),\n    slots: slotsF1Scorer.getResults()\n  }\n}\n"]}