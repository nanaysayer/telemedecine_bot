{"version":3,"sources":["tools/f1-scorer.ts"],"names":["defaultCompare","a","b","MultiClassF1Scorer","constructor","compare","recordsMap","record","actual","expected","tp","_","get","set","fn","fp","getClassResults","cls","precision","recall","f1","getResults","clsF1","Object","keys","map","bind","round","meanBy"],"mappings":"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","sourceRoot":"/src/modules/nlu/src/backend","sourcesContent":["import _ from 'lodash'\n\nexport interface Scorer<T> {\n  record: (actual: any, expected: any) => void\n  getResults: () => T\n  // TODO add evaluate with X[] and Y[]?\n}\n\nexport type F1 = { precision: number; recall: number; f1: number }\ntype classRecords = { tp: number; fp: number; fn: number }\ntype Comparator = (actual: any, expected: any) => boolean\n\nconst defaultCompare: Comparator = (a, b) => a === b\n\n// TODO add loads of test cases for this if this is to stay in the product\nexport default class MultiClassF1Scorer implements Scorer<F1> {\n  private recordsMap: Dic<classRecords>\n\n  constructor(private compare: Comparator = defaultCompare) {\n    this.recordsMap = {}\n  }\n\n  record(actual: string, expected: string) {\n    if (this.compare(actual, expected)) {\n      const tp = _.get(this.recordsMap, `${actual}.tp`, 0) as number\n      _.set(this.recordsMap, `${actual}.tp`, tp + 1)[actual].tp = tp + 1\n    } else {\n      const fn = _.get(this.recordsMap, `${expected}.fn`, 0) as number\n      const fp = _.get(this.recordsMap, `${actual}.fp`, 0) as number\n      _.set(this.recordsMap, `${expected}.fn`, fn + 1)\n      _.set(this.recordsMap, `${actual}.fp`, fp + 1)\n    }\n  }\n\n  getClassResults(cls): F1 {\n    const { tp, fp, fn } = { tp: 0, fp: 0, fn: 0, ...this.recordsMap[cls] }\n    const precision = tp === 0 ? 0 : tp / (tp + fp)\n    const recall = tp === 0 ? 0 : tp / (tp + fn)\n    const f1 = precision === 0 || recall === 0 ? 0 : (2 * precision * recall) / (precision + recall)\n    return { precision, recall, f1 }\n  }\n\n  // We use macro-F1 at the moment, offer options for micro-F1 and weighted-F1\n  getResults() {\n    const clsF1 = Object.keys(this.recordsMap).map(this.getClassResults.bind(this))\n    return {\n      precision: _.round(_.meanBy(clsF1, 'precision'), 2),\n      recall: _.round(_.meanBy(clsF1, 'recall'), 2),\n      f1: _.round(_.meanBy(clsF1, 'f1'), 2)\n    }\n  }\n}\n"]}